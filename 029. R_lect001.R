# lect001
# 陆震
# 日期：2019/05/30

# R是面向对象的，区分大小写的解释型编程语言
# R中多数功能是由程序内置函数、用户自编函数和对对象的创建和操作所实现的
# 对象可以是任何能被赋值给变量的东西，包括常量、数据结构、函数甚至图形
# 每一个对象都有某种模式，描述其是如何存储的，以及某个类属性，R根据其类属性进行相应的操作处理

# 一次交互式会话期间的所有数据对象都被R保存在内存中，所以R往往受限于可用的内存量
# 在处理大数据集的时候，需要考虑数据集的大小和要应用的统计方法

# R函数由函数和赋值构成，R使用 -> 而非 = 作为赋值符号
rnorm(5) -> x # 创建向量对象x，其包含5个来自标准正态分布的随机偏差
x # 直接输入对象的名称将列出它的内容
print(x)
# 函数c()将其参数组合成一个向量或列表，以这样的形式输入数据
c(1, 3, 5, 2, 11, 9, 3, 9, 12, 3) -> age
c(4.4, 5.3, 7.2, 5.2, 8.5, 7.3, 6.0, 10.4, 10.2, 6.1) -> weight
mean(weight) # 求均值
sd(weight) # 求标准差
cor(age, weight) # 求相关系数
plot(age, weight) # 可视化检查两者趋势关系

# 不加参数运行demo()，查看R中图形的完整演示列表
# demo(image)

# help.start() 打开帮助文档首页
# help(foo) 或 ?foo 查看函数foo的描述(如返回值)
# example(foo) 查看函数foo的使用范例
# apropos('foo', mode='function') 列出名称中含有foo的所有可用函数
# data() 列出当前已加载包中所含的所有可用示例数据集

# 工作空间workspace是当前R的工作环境，存储着所有你定义的对象
# 在当前会话结束时，你可以将当前工作空间保存到一个镜像中，以便在下次启动R时自动载入它
# 使用上下方向键查看命令的历史记录

#当前的工作目录working directory是R读取文件和保存结果的默认目录
# getwd() 查看当前工作目录
# setwd() 设定当前工作目录
# 若需要读入一个不再当前工作目录下的文件，需要在调用语句中写明文件的完整路径
# setwd('C:/myprojects/project1') 路径需要使用正斜杠，R将反斜杠 \ 作为一个转义符
# 注意：setwd()不会创建一个新的、不存在的目录
# 可以使用dir.create()创建新目录，然后用setwd()将当前工作目录指向该新目录
runif(20) -> x # 创建一个包含20个均匀分布随机变量的向量
summary(x) # 生成x的摘要统计量
hist(x) # 生成直方图
# 函数q()结束对话，并询问是否保存工作空间
# 若保存工作空间，命令的历史记录保存到文件.Rhistory中，工作空间(包含所有对象)保存到文件.RData中
ls() # 列出当前工作空间中的对象
# rm(objectlist) 删除对象
# history(#) 显示最近使用的#个命令(默认值为25)
# savehistory('myfile') 保存命令历史到文件myfile.Rhistory中
# save.image('myfile') 保存工作空间到文件myfile.RData中
# save(objectlist, file='myfile') 保存指定对象到一个文件中
# loadhistory('myfile') 载入命令历史文件myfile.Rhistory
# load('myfile') 读取工作空间myfile.RData到当前会话中
# 推荐：在独立的目录中保存项目，即跳转到项目所在目录并双击之前保存的镜像文件即可
# 这样可以启动R，载入保存的工作空间，并设置当前工作目录到这个文件夹中

# 输入和输出：
# 函数source('filename')执行脚本文件命令集
# 若文件中不包含路径，R默认该脚本在当前工作目录中
# 惯例，脚本以.R为扩展名，如 source('myscript.R')
# 函数sink('filename')将输出重定向到文件filename中，默认覆盖已有该文件
# 可使用参数append=TRUE将文本追加到该文件后，而不是覆盖它
# 可使用参数split=TRUE将输出同时发送到屏幕和输出文件中
# 不加参数调用sink()，仅向屏幕返回结果
# 注意：sink()只能重定向文本输出，要重定向图形输出，使用以下函数，最后使用dev.off()将输出返回到终端
# bmp('filename.bmp') BMP文件
# jpeg('filename.jpeg') JPEG文件
# pdf('filename.pdf') PDF文件
# png('filename.png') PNG文件
# svg('filename.svg') SVG文件
# 整个输入输出流程如下：
# sink('myoutput', append=TRUE, split=TRUE)
# pdf('mygraphs.pdf')
# source('myscript.R')
# 执行脚本mysript.R，结果显示在屏幕上，此外，文本输出追加到myoutput中，图形输出保存在mygraphs.pdf中

# 包是R函数、数据、预编译代码以一种定义完善的格式组成的集合
# 计算机上存储包的目录称为库library
# 函数.libPaths()显示库所在位置，函数library()显示库中包
# search()显示已加载并可使用的包
# update.packages() 更新已安装的包
# installed.packages() 列出已安装的包的相关信息(如版本号)
# 包的安装是指从某个CRAN镜像站点下载它并将其放入库中的过程
# 安装好以后，必须载入到会话中才能使用包
# help(package='package_name') 输出某个包的简短描述以及包中可用的函数名称和数据集名称的列表
# help() 查看包中任意函数或数据集的描述

# 注意：在调用函数时，即使函数无参数，仍需加上括号()

# 要了解某个函数的返回值，查阅该函数在线帮助文档中的Value部分即可
# 这样可以知道将某个函数的结果赋值到一个对象时，保存的具体内容

# 按照要求的格式创建含有研究信息的数据集，是数据分析的第一步
# 数据集：由数据构成的矩形数组，行为观测(示例)，列为变量(属性)
# 数据集有其数据结构和数据类型(数值型、字符型、逻辑型、复数型和原生型)
# 数据结构：用于存储数据的对象类型，包括标量、向量、矩阵、数组、数据框和列表

# 标量：只含一个元素的向量，用于保存常量
3 -> f
'US' -> g
TRUE -> h

# 向量：用于存储数值型、字符型或逻辑型数据的一维数组
# 执行组合功能的函数c()可用于创建向量
c(1, 2, 3, 4, -5) -> a # 数值型向量
c('one', 'two') -> b # 字符型向量
c(TRUE, FALSE) -> c # 逻辑型向量
# 注意：单个向量中的数据必须是相同的类型(数值型、字符型或逻辑型)，不可混杂不同类型数据
# 索引：访问向量中的元素
a[3]
a[c(2, 4)] # 向量a中第2个和第4个元素
a[2:4] # 向量a中第2到第4个元素

# 矩阵：二维数组，和向量蕾丝，其中元素必须类型相同，即一个矩阵中只能包含一种数据类型
# 可通过函数matrix()创建矩阵
matrix(1:20, nrow = 5, ncol = 4) # 默认按列填充
matrix(1:20, nrow = 5, ncol = 4, byrow=TRUE, dimnames=list(c('r1', 'r2', 'r3', 'r4', 'r5'), 
                                                           c('c1', 'c2', 'c3', 'c4'))) # 按行填充
# 注意：dimnames包含以字符型向量表示的行列名
c('r1', 'r2', 'r3', 'r4', 'r5') -> row_name
c('c1', 'c2', 'c3', 'c4') -> col_name
matrix(1:20, nrow = 5, ncol = 4, byrow=TRUE, dimnames=list(row_name, col_name)) -> X
# 索引：X[i,]表示矩阵X中的第i行，X[,j]表示第j列，X[i, j]表示第i行第j个元素，其中i和j可为数值型向量
X[3,]
X[c(1:3), c(2:3)] # 多行多列
X[c(1:3), c(2:3)] -> Y

# 数组：与矩阵类似，是矩阵的自然推广，不可混杂不同类型数据，维度可以大于2
# 可通过函数array()创建
c('A1', 'A2') -> dim1
c('B1', 'B2', 'B3') -> dim2
c('C1', 'C2', 'C3', 'C4') -> dim3
array(1:24, c(2, 3, 4), dimnames = list(dim1, dim2, dim3)) -> z
# 索引：与矩阵相同
z[1, 2, 3]
z[1, 2, 1:3]







